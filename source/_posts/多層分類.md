---
title: 多層分類
date: 2021-12-08 18:08:16
excerpt: 因專案需求，多重關聯資料表對應A>B>C>D>E
index_img: /img/2021-12-15142513.png
categories: 
- [疑難雜症]
tags: [ PHP, 疑難雜症 , 多重]
---

# <font color=#FF6600>多重分類(關聯資料表)</font>

A、B、C、D、E五個資料表
專案需求要我們呈現
A→多B  //  B→A
B→多C  //  C→B
C→多D  //  D→C
D→多E  //  E→D

他們子代都是複數，而父級都只會有一個

並且資料類型不同，B是兩個資料表的關聯(沒有ID)、C欄位跟DE的欄位名稱不同(不能使用同種函式判斷)

會很需要考驗到自己邏輯

### <font color=#FFD700>介面</font>

![](/img/2021-12-15142513.png)

基本上就是同一個模子上面帶路徑(A)、(A>B)、(A>B>C)...

一般常見的方法看你目前人的位置在哪

所以也就是帶不同資料表進來，然後把除了路徑和關鍵字改一改(新增a的資料、新增b的資料...)

比較麻煩的是上面的路徑帶了名字跟超連結，所以必須要在底下的層級紀錄那一層的狀態

有想過用Session跟cookie去製作，但laravel如何銜接這兩個我還不太會...

~~最後就是紀錄id了，這樣D要跳回A、E要跳回B都會比較方便~~

因為每張資料表的獨特性也不一定有id，所以變成每到下面一層就要多帶一點東西給他，讓他知道該跳回的頁面

當初嘗試用id解決問題，發現E跳到C可以，但E跳D在跳C就不行了(id錯誤)

### <font color=#FFD700>新增</font>

新增功能並不困難，找到對應的資料表去增加就好

將資料表名稱跟新增內容帶過去，只是欄位名稱不同的關係讓後面寫得有些髒

案子的功能用ajax新增欄位用ajax丟然後接回應跳出提醒視窗(自己寫的不是alret)

其中有一個有趣的功能

##### <font color=#008000>動態改變名稱</font>

```javascript
$(function(){
    $('input[name="name"]').change(function() {
        let id = $(this).parent().siblings('td').eq(1).html();
        let name = $(this).val();
        $.post('/Store/updateCategory', {
            mod: '{{$mod}}' ,
            id: id,
            name: name
        }, function(msg) {
            console.log(msg);
        });
    })
})
```

```PHP
    public function saveCategoryName(Request $request, StoreService $service) { 

      $table = request('table');
      $ids = request('id');
      $name = request('name');

      if(!$ids){
          return $this->apiFail('請選擇操作的數據');
      }
    
      $success=DB::table($table)->where('id',$ids)->update(['name'=>$name]);
      if(!$success)
      {
        return $this->apiFail('修改失敗');
      }
      return $this->apiSuccess('修改成功');
    }
```

這樣使input:onchange的時候可以觸發function，將之料丟到後台直接修改。

`$(function(){})`的用意是`document.ready`

`/Store/updateCategory`的連結就是laravel route裡面寫去執行`saveCategoryName()`這個函式

其中還有一個

##### <font color=#008000>Cropper圖片上傳功能</font>

Cropper圖片上傳後可以在編輯圖片大小等等(透過css給他灰階讓他有範圍)

```javascript
  //列表資料圖片處理
  var useCropper = function() {
    
      var crop = [];
      $("div[attr-control='crop']").each(function(i) {
          var id = $(this).attr("attr-id");
          crop[i] = new Croppic('divPreview_' + id, {
              customUploadButtonId: 'upload_btn_file_' + id,
              cropUrl: '{{ build_action('Admin\StoreController@postImgToCrop') }}',
              modal: true,
              doubleZoomControls: true,
              onBeforeImgUpload: function() {
                  //                        $('#divPreview').css('display', 'block');
                  //                        $('.upload-pre-item-mid').css('display', 'none');
              },
              onAfterImgCrop: function(store) {
                  console.log(store);
                  if (store.status != 'success') {
                      updateAlert('網絡發生錯誤，請重試');
                      cropper.reset();
                  }
                  $('#image_' + id).val(store.key);
                  $('#imgHeadPhoto_' + id).prop('src', store.url);
              },
              onError: function() {
                  console.log('error');
              },
              processInline: true,
          });
      })
  }
```

其實這段最後是學長完成的code，因為必須取出id的關係，但上面html又是用foreach產生出來的欄位

其中讓`cropper1`、`cropper2`這種唯一值變成陣列`crop[i]`的方式有獨特名字就讓我大開眼界

本來是用上面foreach帶key值在底下foreach產生，結果反而這樣寫比較直觀

而且each()也是比較方便的用法

### <font color=#FFD700>查詢</font>

查詢功能有一個針對關鍵字的jquery

```javascript
  //搜索關鍵字功能
  $("#search").click(function() {
      var url = $(this).attr('url');
      var query = $('.search-form').find('input').serialize();
      query = query.replace(/(&|^)(\w*?\d*?\-*?_*?)*?=?((?=&)|(?=$))/g, '');
      query = query.replace(/^&/g, '');
      if (url.indexOf('?') > 0) {
          url += '&' + query;
      } else {
          url += '?' + query;
      }
      url += '&id=' + "{{ $id }}" + '&store_id=' + "{{ $store_id }}" + '&mod=' + "{{ $mod }}";
      window.location.href = url;
  });
  //Enter按下去搜索
  $(".search-input").keyup(function(e) {
      if (e.keyCode === 13) {
          $("#search").click();
          return false;
      }
  });
```

在查詢視窗內如果點下ENTER會產生點擊效果

又因為點擊效果會有搜尋的動作產生查詢動作

可以明顯知道

### <font color=#FFD700>刪除</font>

因為多層分類的關係，需要不斷去判斷其他資料表有沒有仍在使用的資料

若資料仍在使用中(有關聯)，就必須跳出提醒不能刪除此資料

由於CDE是同個頁面，所以是關聯再一起使用

```php
public function postCategoryDelete()
  {
    $model = request('mod');
    $ids = request('id');

    //錯誤進入方式
    if (empty($ids)) {
      return $this->ajaxFail('請選擇要操作的數據');
    }

    //*檢查*是否使用中
    $food = [];
    if ($model == 'category_level_2') {
      $level3_id = DB::table('category_level_3')->whereIn('parent_id', $ids)->lists('id');
      $food += DB::table('food')->select('id',$model . '_id', 'category_level_3_id')->whereIn('category_level_3_id', $level3_id)->orWhereIn($model . '_id', $ids)->lists('category_level_3_id');
    }

    if ($model == 'category_level_1') {
      $level2_id = DB::table('category_level_2')->whereIn('parent_id', $ids)->lists('id');
      $level3_id = DB::table('category_level_3')->whereIn('parent_id', $level2_id)->lists('id');
      $food += DB::table('food')->select('id',$model . '_id','category_level_2_id','category_level_3_id')->whereIn('category_level_3_id', $level3_id)->orWhereIn('category_level_2_id', $level2_id)->orWhereIn($model . '_id', $ids)->lists('id');
    }

    if ($model == 'category_level_3') {
      $food += DB::table('food')->select('id', 'category_level_3')->whereIn('category_level_3', $ids)->lists('id');
    }
    if ($food) {
      return $this->ajaxFail('刪除失敗，仍有食物使用到此分類');
      exit();
    } else {
      //*刪除*資料表內容
      if (isset($level2_id)) {
        DB::table('category_level_2')->whereIn('id', $level2_id)->delete();
      }
      if (isset($level3_id)) {
        DB::table('category_level_3')->whereIn('id', $level3_id)->delete();
      }
      $success = DB::table($model)->whereIn('id', $ids)->delete();
      if ($success) {
        $this->onDelete($ids);
        return $this->ajaxSuccess('刪除成功');
      } else {
        return $this->ajaxFail('刪除失敗');
      }
    }
  }
```

~~這段程式已經經過簡化再簡化，我目前的能力就只到這了~~

>2021.12.16 上網找了一下，真的有orWhereIn這個語法，但在laravel文檔中並沒有
>
>然後測試過後發現三個狀態全部寫死最快，只撈一次資料表並將所有要找的東西一次找完，測試小資料最後剩下五秒鐘，在可接受範圍內

當初一開始是將整張資料表撈出

因為資料表過於龐大，所以光檢查資料表就會耗費許多時間，刪除一個資料大概會有五分鐘，造成使用者體驗極差

最後將搜尋欄位減少，針對性的索取資料，不過因為沒有顯示在前台~~，所以連`id`欄位都不撈了~~

希望之後變強大的時候能夠更有效率執行這塊

第一次修正
```php
    DB::table('food')->select('category_level_2_id')->whereIn('category_level_2_id', $level2_id)->lists('category_level_2_id');
    DB::table('food')->select('category_level_3_id')->whereIn('category_level_3_id', $level3_id)->lists('category_level_3_id');
```

最初版
```php
    $level2 = DB::table('category_level_2')->whereIn('parent_id', $ids)->get();
    $level2_id = collect($level2)->pluck('id')->toArray();
    $level3 = DB::table('category_level_3')->whereIn('parent_id', $level2_id)->get();
    $level3_id = collect($level3)->pluck('id')->toArray();
    $food += DB::table('food')->whereIn('category_level_2_id', $level2_id)->get();
    $food += DB::table('food')->whereIn('category_level_3_id', $level3_id)->get();
```

# <font color=#FF6600>總結</font>
---

這次的負責的專案內容其實更考驗思考邏輯的問題，前端頁面可能花了一天從其他資料表拔一拔填一填就結束了

反而是怎麼去跑動程式變的很重要，如果條件變多要怎麼調整搜尋的方式或內容

然後經過這次使用也越來越了解laravel的使用方式，果然直接下去做學習比較快

整體時長總共6天，動作快應該是四天，有兩天在做簡單調整，但如果像目前在閱讀這個文章的大神能力夠強可能幾小時就會解決吧...

所以其實打字速度並不是一定

然後他寫的`ajaxSuccess`、`onAjaxSuccess`等等的功能其實很厲害，就是在基礎的最大框架內放了一個欄位

藉由接收到後端錯誤的時候判斷顏色並顯示(成功綠色、失敗紅色)

```javascript
function onAjaxSuccess(data) {
    if(data && data.status == 1) {
        updateAlert(data.info + ' 頁面即將自動跳轉~','alert-success');
        setTimeout(function(){
            if (data.url) {
                location.href = data.url;
            }
            else{
                location.reload();
            }
        },1500);
    }
    else {
        updateAlert(data.info);
        setTimeout(function () {
            if ($('#top-alert').hasClass('block')) {
                $('#top-alert').removeClass('block');
            }
        },1500)
    }
}
```

這樣的錯誤方式比alret要再次點擊確認的方式好多了，看來又比之前學到更多東西了呢(˘•ω•˘)


